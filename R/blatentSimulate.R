#' @title Simulates data using blatent syntax and simulated parameters input
#'
#' @description Simulates data from a model specified by blatent syntax and using a set of default parameter specifications.
#'
#' @param modelText A character string that contains the specifications for the model to be run. See \code{\link{blatentSyntax}}
#'                  or more information about syntax formatting.
#'
#' @param nObs The number of observations to be simulated.
#'
#' @param defaultSimulatedParameters The specifications for the generation of the types of parameters in the simulation. Currently comprised
#' of a list of unevaluated expressions (encapsulated in quotation marks; not calls for ease of user input) that will be evaluated by
#' simulation function to generate parameters. Defaults to values generated by \code{\link{setDefaultSimulatedParameters}}.
#' The list of unevaluated expressions must include:
#' \itemize{
#'   \item \code{observedIntercepts} The data generating function for all intercepts for observed variables.
#'   \item \code{observedMainEffects} The data generating function for the main effects for observed variables.
#'   \item \code{observedInteractions} The data generating function for all interactions for observed variables.
#'   \item \code{latentIntercepts} The data generating function for all intercepts for latent variables.
#'   \item \code{latentMainEffects} The data generating function for the main effects for latent variables.
#'   \item \code{latentInteractions} The data generating function for all interactions for latent variables.
#' }
#'
#' @examples
#'
#' # Generating data using Q-matrix structure from data example in Chapter 9 of Rupp, Templin, & Henson (2010).
#' RTHCh9ModelSyntax = "
#'    item1 ~ A1
#'    item2 ~ A2
#'    item3 ~ A3
#'    item4 ~ A1 + A2 + A1:A2
#'    item5 ~ A1 + A3 + A1:A3
#'    item6 ~ A2 + A3 + A2:A3
#'    item7 ~ A1 + A2 + A3 + A1:A2 + A1:A3 + A2:A3 + A1:A2:A3
#'
#'    # Latent Variable Specifications:
#'    A1 A2 A3 <- latent(unit = 'rows', distribution = 'bernoulli', structure = 'univariate', type = 'ordinal')
#'
#'    # Observed Variable Specifications:
#'    item1-item7 <- observed(distribution = 'bernoulli', link = 'probit')
#' "
#'
#' simSpecs = setDefaultSimulatedParameters(
#'    observedIntercepts = "runif(n = 1, min = -1, max = -1)",
#'    observedMainEffects = "runif(n = 1, min = 2, max = 2)",
#'    observedInteractions = "runif(n = 1, min = 0, max = 0)",
#'    latentIntercepts = "runif(n = 1, min = 0, max = 0)",
#'    latentMainEffects  = "runif(n = 1, min = 0, max = 0)",
#'    latentInteractions = "runif(n = 1, min = 0, max = 0)"
#'  )
#'
#' simulatedData = blatentSimulate(modelText = RTHCh9ModelSyntax, nObs = 1000, defaultSimulatedParameters = simSpecs)
#'
#' @references Rupp, A. A., Templin, J., & Henson, R. A. (2010). Diagnostic Measurement: Theory, Methods, and Applications. New York: Guilford.
#'
#' @export
blatentSimulate = function(modelText, nObs, defaultSimulatedParameters = setDefaultSimulatedParameters(), seed = NULL){

  set.seed(seed = seed)
  seed = .Random.seed

  # grab model vector from modelText
  parsedText = parseModelSyntax(modelText = modelText)

  # next determine dependencies in data
  modelVector = parsedText$modelVector
  modelOrder = determineDependencies(modelVector = parsedText$modelVector)

  # get dependent variables from observed Vector:
  allDVs = lapply(X = parsedText$modelVector, FUN = function(x) return(all.vars(terms(x)[[2]])))

  # initialize data to allow use of R model.matrix commands
  tempData = matrix(NA, nrow = nObs, ncol = length(modelOrder))
  colnames(tempData) = allDVs
  simData = data.frame(tempData)

  # initialize data to random values to enable correct names from model.matrix() used below
  for (col in 1:ncol(simData)){
    simData[,col] = rnorm(nObs)
  }

  # initialize functions for creating variables:

  # initialize values for parameters
  trueValues = list()

  # generate data in order:
  v = 4
  for (v in 1:length(modelOrder)){

    varName = modelOrder[v]

    trueValues[[varName]] = list()
    # determine where this lies in the modelVector:
    modelNumber = which(allDVs == varName)

    # get parameter names
    paramNames =  colnames(model.matrix(parsedText$modelVector[[modelNumber]], data = simData))

    # get variable type and predictor types
    varType = parsedText$details[[varName]]$type

    # get predictor types to see if ordinal predictors are noted here
    predictors = all.vars(parsedText$modelVector[[modelNumber]][[3]])
    predTypes = unlist(lapply(X = all.vars(predictors), FUN = function(x) return(parsedText$details[[x]]$type)))


    # get information about parameters
    p=4



    # change so that simulated parameters observe ordinal monotonicity constraints
    if (any(predTypes == "ordinal")) {
      # monotonicity constraints apply (for now, doing so without mixed types)
      constraintMatrix = makeConstraintMatrixGeneral(
        model = formula(parsedText$modelVector[[modelNumber]]),
        categoricalLatentVariables = predictors
      )
      constraintTest = rep(-1, length(paramNames))
      while(any(constraintTest <= 0)){
        trueValues[[varName]]$paramVec = NULL
        for (p in 1:length(paramNames)) {
          if (length(grep(pattern = "(Intercept)", paramNames[p])) > 0) {
            # parameter is intercept: draw parameter
            if (parsedText$details[[varName]]$isLatent) {
              simValue = eval(parse(text = defaultSimulatedParameters$latentIntercepts))
            } else {
              simValue = eval(parse(text = defaultSimulatedParameters$observedIntercepts))
            }
          } else if (length(grep(pattern = ":", paramNames[p])) > 0) {
            # parameter is interaction: draw parameter
            # parameter is intercept: draw parameter
            if (parsedText$details[[varName]]$isLatent) {
              simValue = eval(parse(text = defaultSimulatedParameters$latentInteractions))
            } else {
              simValue = eval(parse(text = defaultSimulatedParameters$observedInteractions))
            }
          } else {
            # parameter is main effect
            # parameter is intercept: draw parameter
            if (parsedText$details[[varName]]$isLatent) {
              simValue = eval(parse(text = defaultSimulatedParameters$latentMainEffects))
            } else {
              simValue = eval(parse(text = defaultSimulatedParameters$observedMainEffects))
            }
          }

          trueValues[[varName]]$paramVec = c(trueValues[[varName]]$paramVec, simValue)
          trueValues[[varName]][[paramNames[p]]] = simValue
        }
        constraintTest = constraintMatrix %*% matrix(trueValues[[varName]]$paramVec, ncol = 1)
      }


    } else {
      for (p in 1:length(paramNames)) {
        if (length(grep(pattern = "(Intercept)", paramNames[p])) > 0) {
          # parameter is intercept: draw parameter
          if (parsedText$details[[varName]]$isLatent) {
            simValue = eval(parse(text = defaultSimulatedParameters$latentIntercepts))
          } else {
            simValue = eval(parse(text = defaultSimulatedParameters$observedIntercepts))
          }
        } else if (length(grep(pattern = ":", paramNames[p])) > 0) {
          # parameter is interaction: draw parameter
          # parameter is intercept: draw parameter
          if (parsedText$details[[varName]]$isLatent) {
            simValue = eval(parse(text = defaultSimulatedParameters$latentInteractions))
          } else {
            simValue = eval(parse(text = defaultSimulatedParameters$observedInteractions))
          }
        } else {
          # parameter is main effect
          # parameter is intercept: draw parameter
          if (parsedText$details[[varName]]$isLatent) {
            simValue = eval(parse(text = defaultSimulatedParameters$latentMainEffects))
          } else {
            simValue = eval(parse(text = defaultSimulatedParameters$observedMainEffects))
          }
        }

        trueValues[[varName]]$paramVec = c(trueValues[[varName]]$paramVec, simValue)
        trueValues[[varName]][[paramNames[p]]] = simValue
      }



    }

    linPred = model.matrix(parsedText$modelVector[[modelNumber]], data = simData) %*% matrix(trueValues[[varName]]$paramVec, ncol = 1)
    # generate data
    simData[varName] = parsedText$details[[varName]]$generationFunction(n = nObs,
                                                                        variableOptions = list(linearPredictor = linPred,
                                                                                               inverseLinkFunction = parsedText$details[[varName]]$inverseLinkFunction))

  }

  simOutput = blatentSimulatedData$new(nObs = nObs, simModel = modelText, defaultSimulatedParameters = defaultSimulatedParameters,
                                       seed = seed, details = parsedText$details, data = simData, trueValues = trueValues)
  return(simOutput)

}
